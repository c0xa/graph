<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Graph</title>
    <base href="/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="src/assets/base/base/images/favicon.ico">
</head>
<body>

<!-- Page loading animation
  All styles are embedded in index.html in order to dive as soon as possible -->
<div class="page-loader" #loader>
    <div class="page-loader__spinner"></div>
    <div class="page-loader__spinner"></div>
    <div class="page-loader__spinner"></div>
</div>
<style>
    .page-loader {
        background: #FFFFFF;

        width: 100%;
        height: 100%;

        position: fixed;

        top: 0;
        left: 0;

        z-index: 999;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    }

    .page-loader.hidden {
        display: none;
    }

    .page-loader__spinner {
        position: absolute;
        width: 100px;
        height: 100px;
        border: 2px solid #6200EE;
        border-radius: 20%;
    }

    /* Animation for each element, but with a shift in start time */
    .page-loader__spinner:nth-child(1) {
        opacity: .8;
        animation: page-loader-spinner-anim 4s 0s ease-in-out infinite alternate;
    }

    .page-loader__spinner:nth-child(2) {
        opacity: .6;
        animation: page-loader-spinner-anim 4s .2s ease-in-out infinite alternate;
    }

    .page-loader__spinner:nth-child(3) {
        opacity: .4;
        animation: page-loader-spinner-anim 4s .4s ease-in-out infinite alternate;
    }

    /* Animation using transform functions, which is performed on the GPU */
    /* Thus, the script can hang the page, but the animation will continue to be executed */
    @keyframes page-loader-spinner-anim {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }
</style>
    <app-root
    [loader]="loader"
    ></app-root>
</body>
</html>




<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .links line {
        stroke: #999;
        stroke-opacity: 0.3;
    }

    .nodes circle {
        stroke: #fff;
        stroke-width: 1px;
    }

</style>
<svg width="1960" height="1600"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

     var svg = d3.select("svg"),
         width = +svg.attr("width"),
         height = +svg.attr("height");

     var color = d3.scaleOrdinal(d3.schemeCategory20);

     var simulation = d3.forceSimulation()
         // .force('charge',
         //     d3.forceCollide()
         //         .strength(1)
         //         .radius((d) =>  100)
         //         .iterations(1)
         // )
         // .force('collide',
         //     d3.forceManyBody()
         //         .strength((d) => -1 * d['r'] + 25)
         // )
         .force("link", d3.forceLink().id(function(d) { return d.id; }))
         .force("charge", d3.forceManyBody())
         .force("center", d3.forceCenter(width / 2, height / 2));

     d3.json("assets/miserables.json", function(error, graph) {
         if (error) throw error;

         var link = svg.append("g")
             .attr("class", "links")
             .selectAll("line")
             .data(graph.links)
             .enter().append("line")
             .attr("stroke-width", function(d) { return Math.sqrt(d.value); });

         var node = svg.append("g")
             .attr("class", "nodes")
             .selectAll("circle")
             .data(graph.nodes)
             .enter().append("circle")
             .attr("r", 15)
             .attr("fill", function(d) { return color(d.group); })
             .call(d3.drag()
                 .on("start", dragstarted)
                 .on("drag", dragged)
                 .on("end", dragended));

         node.append("title")
             .text(function(d) { return d.id; });

         simulation
             .nodes(graph.nodes)
             .on("tick", ticked);

         simulation.force("link")
             .links(graph.links);

         function ticked() {
             link
                 .attr("x1", function(d) { return d.source.x; })
                 .attr("y1", function(d) { return d.source.y; })
                 .attr("x2", function(d) { return d.target.x; })
                 .attr("y2", function(d) { return d.target.y; });

             node
                 .attr("cx", function(d) { return d.x; })
                 .attr("cy", function(d) { return d.y; });
         }
     });

     function dragstarted(d) {
         if (!d3.event.active) simulation.alphaTarget(0.3).restart();
         d.fx = d.x;
         d.fy = d.y;
     }

     function dragged(d) {
         d.fx = d3.event.x;
         d.fy = d3.event.y;
     }

     function dragended(d) {
         if (!d3.event.active) simulation.alphaTarget(0);
         d.fx = null;
         d.fy = null;
     }

</script>
